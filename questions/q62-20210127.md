### 写在前面

> 此系列来源于开源项目：[前端 100 问：能搞懂 80%的请把简历给我](https://github.com/yygmind/blog/issues/43)
> 为了备战 2021 春招
> 每天一题，督促自己
> 从多方面多角度总结答案，丰富知识
> [redux 为什么要把 reducer 设计成纯函数](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/107)
> 简书整合地址：[前端 100 问](https://www.jianshu.com/c/70e2e00df1b0)

#### 正文回答

首先命题应当改一下，中文有歧义，可能改为 “redux 中的 reducer 为什么必须（最好）是纯函数“，我想表达的意思是，`redux` 没有强制你 `reducer` 是个纯函数，事实上，没有人能通过框架限制判断一个函数是否是纯函数，所以题目中的'设计成'这个短语貌似在说 `redux` 已经把 `reducer` 强制规定是纯函数了。这回让你怀疑你对 `redux` 的认知。

正文如下

然后说一下为什么 `reducer` 最好是纯函数，首先你得看看文档怎么说 `reducer` 的作用的，‘接收旧的 `state` 和 `action`，返回新的 `state`’，您可得瞧好咯，他就是起一个对数据做简单处理后返回 `state` 的作用，为什么只起这个作用，这时用设计这个词回答这个问题才恰当，因为 `redux` 把 `reducer` 设计成只负责这个作用。

很白痴的问答对吧，所以题目的答案也就简单了，`reducer` 的职责不允许有副作用，副作用简单来说就是不确定性，如果 `reducer` 有副作用，那么返回的 `state` 就不确定

举个例子，你的 `reducer` 就做了一个 `value = value + 1` 这个逻辑，然后返回 `state` 为`{value}`，ok，这个过程太 jr 纯了，然后你可能觉得要加个请求来取得 value 后再加 1，那么你的逻辑就是 `value = getValue() + 1`, `getValue` 是个请求函数，返回一个值，这种情况，退一万步讲，如果你的网络请求这次出错，那么 `getValue` 就返回的不是一个数值，value 就不确定了，所以 `return` 的 `state` 你也不确定了，前端 UI 拿到的数据也不确定了，所以就是这个环节引入了副作用，他娘的 `redux` 设计好的规范就被你破坏了，`redux` 就没卵用了。到此为止这个问题回答完了，我没有说什么上面几个 jr 说的教科书的理论，甚至还加了些脏话。请原谅，这只是戏剧需要。

最后我回答下如何解决这个副作用，实际上也很白痴的问题，这里的请求可以放在 `reducer` 之前，你先请求，该做出错处理的就做出错处理，等拿到实际数据后在发送 `action` 来调用 `reducer`。这样通过前移副作用的方式，使 `reducer` 变得纯洁。
